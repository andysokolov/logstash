input {
#  stdin {
#    type => "ezproxylog"
#    debug => true
#  }
#  file {
#    debug => true
#    discover_interval => 1
#    path => [ "/home/kibana/logstash-import/ezproxy/logs/ezproxy*.log" ]
#    start_position => "beginning"
#    type => "ezproxylog"    
#  }
  tcp {
    # Set up logstash to listen on port 5544 for syslog messages
    type => "ezproxylog"
    port => 5544
    host => "10.22.4.214"
   debug => true
  }
#  udp  {
#    # Set up logstash to listen on port 5544 for syslog messages
#    type => "ezproxylog"
#    port => 5544
#    host => "10.22.4.214"
#   debug => true
#  }
}

filter {
  grok {
    type => "ezproxylog"
    # Default EZproxy LogFormat command:
    # LogFormat %h %l %u %t "%r" %s %b
    # Where:
    #  h = Host accessing EZproxy (always IP address).
    #  l = Remote username obtained by idented (identd is not used, so this always inserts -).
    #  u = Username or Session Identifier
    #  t = Date/time of request. Can appear as %{format}
    #  r = Complete request
    #  s = HTTP numeric status code
    #  b = Number of bytes transferred
    # Extract the EZProxy event as syslog_message.
    pattern => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{DATA:syslog_logsource}: %{GREEDYDATA:syslog_message}"
  }
  grok {
    # Extract fields from EZProxy event.
    type => "ezproxylog"
    match => [ "syslog_message", "%{IP:clientip} %{USER:ezproxy_remote_username} %{USER:ezproxy_request_username} \[%{HTTPDATE:ezproxy_timestamp}\] %{QS:ezproxy_request_raw} %{NUMBER:ezproxy_response} %{NUMBER:ezproxy_bytes} %{QS:referrer} %{QS:user_agent}" ]
  }
  mutate {
    # Assign syslog timestamp and source to new fields.
    type => "ezproxylog"
    add_field => [ "logstash_timestamp", "%{@timestamp}" ]
    add_field => [ "logstash_logsource", "%{@source_host}" ]
  } 
  grok {
    # Add field requested_host to the output, matching on URIHOST from requested_uri field.
    type => "ezproxylog"
    match => [ "ezproxy_request_raw", "%{URIPROTO}://(?:%{USER}(?::[^@]*)?@)?(?:%{URIHOST})?(?:%{URIPATH}(?:%{URIPARAM:ezproxy_querystring})?)?" ]
  }
  grok {
    type => "ezproxylog"
    match => [ "ezproxy_querystring", "url=%{GREEDYDATA:ezproxy_target}" ]
  }
  grok {
    type => "ezproxylog"
    match => [ "ezproxy_target", "%{URIPROTO}://(?:%{USER}(?::[^@]*)?@)?(?:%{URIHOST:target_host})?" ]
  }
  date {
    type => "ezproxylog"
    # Try to set the @timestamp field from the 'timestamp' field (parsed above with
    # grok).
    match => [ "ezproxy_timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
  } 
  mutate {
    # Replace source field values with the values we want from EZProxy.
    type => "ezproxylog"
    exclude_tags => "_grokparsefailure"
    replace => [ "@message", "%{syslog_message}" ]
  }
  # Remove duplicate and unimportant fields.
  mutate {
    remove => [ "ezproxy_remote_username", "ezproxy_request_username", "ezproxy_timestamp", "ezproxy_querystring", "ezproxy_request_raw", "syslog_timestamp", "syslog_message", "@source_host", "@source_path", "@source" ]
  }
  # Do some value-added stuff like GeoIP lookups and User Agent parsing.
   geoip {
     type => "ezproxylog"
     # Try to get GeoIP lookup using value from the 'clientip' field (parsed above with
     # grok).
     source => "clientip"
   }
  useragent {
    type => "ezproxylog"
    source => "user_agent"
  } 
}

output {
  # Uncomment stdout{} for debugging.
  stdout {
    type => "ezproxylog"
    debug => true
    message => "%{@message}"
  }
  elasticsearch_river {
    debug => true
    #embedded => true
    type => "ezproxylog"
    es_host => "libraryweb.kumc.edu"
    rabbitmq_host => "libraryweb.kumc.edu"
    user => "guest"
    #embedded_http_port => "9200-9300"
  }
}
