input {
#  stdin {
#    type => "ezproxylog"
#    debug => true
#  }
#  file {
#    debug => true
#    discover_interval => 1
#    path => [ "/home/kibana/logstash-import/ezproxy/logs/ezproxy*.log" ]
#    start_position => "beginning"
#    type => "ezproxylog"    
#  }
  tcp {
    # Set up logstash to listen on port 5544 for syslog messages
    type => "ezproxylog"
    port => 5544
    host => "10.22.4.214"
   debug => true
  }
  udp  {
    # Set up logstash to listen on port 5544 for syslog messages
    type => "ezproxylog"
    port => 5544
    host => "10.22.4.214"
   debug => true
  }
}

filter {
  grok {
    type => "ezproxylog"
    # Default EZproxy LogFormat command:
    # LogFormat %h %l %u %t "%r" %s %b
    # Where:
    #  h = Host accessing EZproxy (always IP address).
    #  l = Remote username obtained by idented (identd is not used, so this always inserts -).
    #  u = Username or Session Identifier
    #  t = Date/time of request. Can appear as %{format}
    #  r = Complete request
    #  s = HTTP numeric status code
    #  b = Number of bytes transferred
    #pattern => "%{SYSLOGTIMESTAMP} %{SYSLOGHOST:logsource} %{WORD}
    pattern => "%{SYSLOGTIMESTAMP} %{DATA:syslog_logsource}: %{IP:client_ip} %{USER:request_remote_username} %{USER:request_username} \[%{HTTPDATE:timestamp}\] %{QS:request_raw} %{NUMBER:response} %{NUMBER:bytes} %{QS:referrer} %{QS:user_agent}"
    #pattern => "%{WORD:ezproxy_logformat} %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer}"
# %{QS:agent}"
  }
  
  date {
    type => "ezproxylog"
    # Try to set the @timestamp field from the 'timestamp' field (parsed above with
    # grok).
    match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
  }
   geoip {
     type => "ezproxylog"
     # Try to get GeoIP lookup using value from the 'client_ip' field (parsed above with
     # grok).
     source => "client_ip"
   }
  grok {
    # Add field requested_host to the output, matching on URIHOST from requested_uri field.
    type => "ezproxylog"
    match => [ "request_raw", "%{URIPROTO}://(?:%{USER}(?::[^@]*)?@)?(?:%{URIHOST})?(?:%{URIPATH}(?:%{URIPARAM:request_querystring})?)?" ]
  }
  grok {
    type => "ezproxylog"
    match => [ "request_querystring", "url=%{GREEDYDATA:request_target}" ]
  }
  kv {
    # Use kv to parse querystring into key => value pairs. 
    type => "ezproxylog"
    source => "request_querystring"
    field_split => "&?"
    target => "request_params" 
  }   
  useragent {
    type => "ezproxylog"
    source => "user_agent"
  }
}

output {
  stdout {
    type => "ezproxylog"
    debug => true
    message => "%{@message}"
  }
#  elasticsearch {
#    embedded => true
#    type => "ezproxylog"
#  }
}
